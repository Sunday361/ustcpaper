% !TeX root = ../main.tex

\chapter{绪论}

\section{研究背景和意义}

传统的数据库管理系统(DBMS)通常是采用基于磁盘的设计,原因在于早期数据库管理
系统设计时受到了硬件资源如单CPU、单核、可用内存小等条件的限制，把整个数据库放到内
存里是不现实的,只能放在磁盘上。由于磁盘是一个非常慢的存储设备(相对于 CPU 的速度),
因此学术界和工业界发展出的数据库管理系统在架构上都必须适应当时的硬件条件,沿用至今
的 Oracle 和 MySQL 等数据库管理系统仍然采用的是这种架构设计\cite{ailamaki1999dbmss}
\cite{ailamaki2002data}。
伴随着技术的发展,内存已经越来越便宜,容量也越来越大。单台计算机的内存可以配置
到几百 GB 甚至 TB 级别。对于一个数据库应用来说,这样的内存配置已经足够将所有的业务
数据加载到内存中进行使用。虽然大数据处理的数据量可能是 PB 级别的,但那些数据一般是
非结构化的数据。通常来讲,结构化数据的规模并不会特别大,例如一个银行 10 年到 20 年的
交易数据加在一起可能只有几十 TB。这样规模的结构化数据如果放在基于磁盘的 DBMS 中,
在面对大规模 SQL 查询和交易处理时,受限于磁盘的 I/O 性能,很多时候数据库系统会成为整
个应用系统的性能瓶颈。
如果我们为数据库服务器配置足够大的内存,是否可以仍然采用原来的架构,通过把所有
的结构化数据加载到内存缓冲区中,就可以解决数据库系统的性能问题呢?这种方式虽然能够
在一定程度上提高数据库系统的性能,但在日志机制和更新数据落盘等方面仍然受限于磁盘的
读写速度,远没有发挥出大内存系统的优势。内存数据库管理系统和传统基于磁盘的数据库管
理系统在架构设计和内存使用方式上还是有着明显的区别。由于内存数据库与传统的磁盘数据
库在设计和架构上都大不相同,所以传统的数据库索引不适用于内存数据库。需要内存数据库
研究人员针对这些特点对数据库索引算法进行改进和重新设计,才能尽可能的发挥出内存数据
库的性能优势,因此更为深入的研究内存数据库的索引算法,意义非常重大。

基于上述背景，事物型内存数据库系统的性能很大程度上取决与于内存中的数据结构在并发操作的
性能。传统的方法中，通常基于悲观锁设计并发的数据结构，但是这在当前新的硬件环境上往往不
具备扩展性。因为当同时有多个线程并发操作的时候，会同时竞争锁的所有权，随着线程数的增多
这种情况会越来越严重。因此实际情况下会使用读写锁等来优化这种情况，但是实际上并没有解决锁竞争的
问题，只是缩小了锁竞争的粒度。

传统的面向磁盘的数据库，都会采用基于悲观锁或读写锁的方式来保证数据结构的并发访问。
这种方式在面向磁盘的数据库中是有效的，因为传统数据库的瓶颈并不在cpu，而是在IO的速度。
内存数据库尤其是运行在具备多核处理器的平台上，这种锁的开销就会愈发明显，甚至影响到了
数据库的整体性能。

随着内存数据库的提出和发展，越来越多的内存数据库开始重新设计新的索引结构，他们有基于之前的B树模型设计的
如Bw-Tree\cite{alvarez2015comparison}
\cite{leis2016art}，也有新的数据结构比如跳表，学术界对此有诸多的研究和测试。尤其是基于乐观锁的数据库索引结构，比如说
微软第一次在他的数据库SQL Server的Hekaton引擎中提出的一种lock-free的索引结构。
Bw-Tree主要是通过在逻辑记录和实际物理记录之间加了一层中间层，这种方式可以避免对实际的物理记录加锁，多个线程
通过compare-and-swap的方式来追加新的记录到树的节点中。某个操作之后的一系列操作都需要回放这条所谓版本链来获得
真实的记录。这种中间层主要有两个优势，其一，通过将全局状态的变更分解为多个原子操作而避免了锁的争用的开销;其二，由于线程只是
追加变更到记录上而不是在实际的物理页面上进行修改，因此避免了多核处理器上Cache的失效。
但是正确的实现上述的过程并不是一件简单的事情。而且微软并没有将Bw-Tree的代码开源，而开源版本的BwTree在并发场景下并不能获得优秀的性能。

此外，Hyper团队采用的Adaptive Radix Tree（以下简称为ART）作为其内存数据库Hyper的索引结构，Hpyer团队认为传统的平衡树
并不能有效的利用现代CPU的Cache，其最大的优点在于其有出色的查询性能，同时插入和删除的性能也较为出色。同时也解决了前缀树中
空间浪费的问题。随之而来的是针对这一索引结构的并控制算法的研究。

图1中是来自Hyper团队的论文中的结论。其中描述了多种并发模型，包括基于悲观锁的方式，硬件事务内存
乐观锁，乐观级联锁，悲观级联锁，ROWEX。可以看到虽然硬件事务内存(Hardware Transactionl Memory)
在易用性和可扩展性上均处于优势，但是需要额外的硬件支持,因此并不具备通用性。本文中使用的并发控制机制
还是选取的乐观级联锁的方式。
  
本课题来源于华为自研的内存数据库,目的是研究内存数据库索引模块相关技术。
华为数据库部门希望将部分索引模块代码替换为硬件执行逻辑以提升数据库的数据处理
性能,但是这一需求对索引模块的多核扩展性有较高要求,因此我们着重设计和实现基于乐观
锁的索引算法,这其中我们根据已有的论文和资料设计基于乐观级联锁的 ART 索引算法,
同时根据实际的使用场景提出自己的优化点。这一索引算法极大地避免数据的争用问题,在内
存数据库这一应用场景下具备较好的扩展性和实用性。我们也针对 ART 索引进行了部分优化,
比如采用无锁化的预分配内存的内存管理机制替代常规内存分配和基于 epoch 的垃圾内存回收
4机制。其次,常规 ART 索引需要进行路径压缩,但是进行路径压缩导致路径上不能存储完
整的索引字段,在查询索引时需要进行回表查询获得其对应的索引字段,这一操作会增加索引
查询的开销,所以我们考虑不采取路径压缩,这涉及到重新设计 ART 中这部分代码逻辑。

我们知道，由于机械磁盘受限于磁头寻址过程，读写通常都以一块（block）为单位，故在操作系统中被抽象为块设备，与流设备相对。
这能帮助上层应用是更好地管理储存空间、增加读写效率等。
这一特性直接影响了数据库储存格式的设计：数据库的 Page 对应一个或几个物理扇区，让数据库的 Page 和扇区对齐，提升读写效率。
那如何将数据存放到页上呢？

大多数服务于在线查询的 DBMS 采用 NSM (N-ary Storage Model) 即按行存储的方式，
将完整的行（即关系 relation）从 Header 开始依次存放。页的最后有一个索引，存放了页内各行的起始偏移量。
由于每行长度不一定是固定的，索引可以帮助我们快速找到需要的行，而无需逐个扫描。
NSM 的缺点在于，如果每次查询只涉及很小的一部分列，那多余的列依然要占用掉宝贵的内存以及 CPU Cache，从而导致更多的 IO；
为了避免这一问题，很多分析型数据库采用 DSM (Decomposition Storage Model) 即按列分页：将 relation 按列拆分成多个 sub-relation。
类似的，页的尾部存放了一个索引。2001 年 Ailamaki 等人提出 PAX (Partition Attributes Cross) 格式，尝试将 DSM 的一些优点引入 NSM，
将两者的优点相结合。具体来说，NSM 能更快速的取出一行记录，这是因为一行的数据相邻保存在同一页；DSM 能更好的利用 CPU Cache 以及使用更紧凑的压缩。
PAX 的做法是将一个页划分成多个 minipage，minipage 内按列存储，而一页中的各个 minipage 能组合成完整的若干 relation。
我们在内存数据库中也会使用该数据组织方式。以上设计优化思路在于提高数据库
索引模块的查询处理数据的性能,避免额外的垃圾回收带来的性能损耗,选取合适的存储结构
提高 cache 命中率,进而提高系统吞吐量,降低查询时延。

\section{国内外研究历史与现状}

内存数据库领域在设计索引时,主要是从面向缓存的索引技术(Cache-Awareness)和多核
多 CPU 的并行处理(Multi-Core and Multi-Socket Parallelism)两方面进行考虑\cite{lim2017cicada}
\cite{neumann2015fast}
\cite{nam2019write}。
由于内存数据库不再有磁盘的 I/O 限制,因此索引目的转变为加速 CPU 和内存之间的访问
速度。虽然现在内存价格较低,但是内存速度的增速与 CPU 主频的增速相差依然较多,因此
对于内存数据库,索引技术的目的是以尽量快的速度将所需数据放入 CPU 的 Cache 中。
对于多核多 CPU 的并行处理,80 年代就开始考虑如果数据结构和数据都放在内存中,应
该如何合理的构造索引。其中,1986 年威斯康星大学的 MM-DBMS 项目提出了自平衡的二叉
搜索树 T-Tree 索引,每个二叉节点中存储取值范围内的数据记录,同时有两个指针指向它的两
个子节点。T-Tree 索引结构内存开销较小,因为在 80 年代内存昂贵,所以主要的度量不在于性
能是否最优,而是是否占用最小内存空间。T-Tree 的缺点是性能问题,需要定期地做负载平衡,
并且扫描和指针也会对其性能产生影响。早期商业系统如 Times Ten 中,采用的便是 T-Tree 的
数据结构。

那么索引的设计为什么需要考虑 Cache-Awareness 呢？
1999 年有研究发现内存访问中的 Cache Stall 或者 Cache Miss 是内存系统最主要的性能瓶颈[15]。
如图 1 所示，通过对 A/B/C/D 4 个系统评测，
测试以下过程的时间占比：Computation、Memory Stalls、Branch Mispredicitons 和 Resource Stalls。
Computation 表示真正用于计算的时间；Memory Stall 是等待内存访问的时间；
Branch Mispredicitons 是指 CPU 指令分支预测失败的开销；
Resource Stalls 是指等待其他资 源的时间开源，如网络、磁盘等;

因此我们选取内存数据库的索引必须要考虑到Cache-Awareness，传统的b树系列索引由于是专门为磁盘设计，在内存中
往往是维护一个buffer pool管理内存中的页面，在需要对页面进行读取或修改时再从磁盘上读取。因此传统数据库需要解决的
性能瓶颈主要是磁盘IO的速度。因此其往往不需要考虑Cache-Awareness。

但是内存数据库中，Cache命中率对性能的影响就较大了。传统的b树索引以page为单位组织索引，且原地更新索引的方式，没有考虑
cache对性能的影响。因此微软在b+树的基础上推出了Bw-Tree。


对于多核多CPU来说，主要在于提高索引的可扩展性，即在单核单线程和多核多线程下性能对比没有明显下降，甚至多线程情况下性能应该是
线性关系的增长。尽管Bw-Tree的作者宣称其在多核下可扩展性较好，但是在CMU的文章中着重对比几种基于锁或者基于乐观锁的索引结构性能
比较中。Bw-tree的性能并不尽如人意，尽管之前的篇幅中描述的基于lock-free的索引结构在多核场景下优于基于锁的索引，但是实际上
Bw-Tree的实际数据结构和版本链之间的间隔层（Indirection Layer）以及追加记录的开销导致其性能在多核场景下还弱于基于lock的索引。
\cite{bottcher2019scalable}
但是我们从Bw-Tree论文中发现ART索引的各项性能均较为突出。下图是该篇论文中关于多种内存数据库中索引的性能对比。针对递增键值的
单线程负载，ART的读和读更新性能较为突出。而随机键值情况下读更新的性能也是最高的。
对于20线程并发操作的场景下，ART的插入，更新，读取性能均为最佳\cite{huang2022opportunities}
\cite{lee2017wort}\cite{wang2018building}。因此本文选取了ART索引作为内存数据库系统使用的二级索引，使用
乐观级联锁处理索引结构的并发控制。

\section{本文研究内容及章节安排}

本文设计一种适合内存数据库中使用的二级索引技术展开，通过对现有内存数据库索引的设计方法的研究，选取一种适合当前应用场景的
内存数据库索引。基于乐观级联锁的ART索引。该索引通过节点可伸缩的方式，解决了传统前缀树索引内存的利用率低的问题。
同时应用乐观级联锁处理对索引结构的并发控制，提高其在多核多线程平台上并发读写的性能，使用乐观锁而非悲观锁在于保证其并发访问
的可扩展性。同时ART索引可以提高索引操作Cache命中率，进而进一步提高性能。

而且目前系统采用冯诺伊曼架构，虽然获得了很大的通用性，但是在性能上却不得不作出妥协。
因此我们研究这种基于乐观锁方式的数据库内存索引的最终目的是希望可以将部分的处理逻辑交由专门的硬件处理，所有的
操作都可以获得硬件上的真正的并行。正是这个最终需求催生着我们需要设计具备良好扩展性的数据库索引。

我们认为实际硬件的并行需要我们的数据库索引具备良好的可扩展性。因此我们会重点关注索引的可扩展性，主要的测试场景也会优先
关注其在少写多读并发进行时的并发度状况，这在后面的章节将会详细说明。

本文章具体内容组织形式如下:

第一章介绍了设计一种适应内存数据库使用环境下具有优良性能的索引结构的意义和必要性，分析了现有的面向磁盘设计的数据库索引结构
的不足，以及其面临的问题。其次列举了当前已有的实验结论，介绍了微软特地为内存数据库设计的Bw-Tree，以及引用了CMU实验的结论，
就是Bw-tree在cache-Awareness和多核扩展性方面的性能均不如ART。由此引出了本文为什么要使用ART这种数据结构进行内存索引的设计，
以及为什么要设计基于乐观并发的索引模块。

第二章简单概述现有的主要几种内存数据库索引类型，以及这些数据库索引是采用哪种并发控制。我们分别从这几种内存数据库索引中参考
和实现了哪一部分的技术。

第三章首先简单介绍了ART索引的模块设计。主要包括索引节点模块的详细设计，介绍了如何基于乐观级联锁的方式进行并发控制的详细设计。
索引操作算法的详细设计，包括索引常用的插入，删除，单点查询，范围查询等。此外由于引入了乐观锁的结构，如何处理被删除节点，介绍了
Bw-Tree中采用的基于epoch的垃圾回收机制和我们使用的预先分配好索引内存，使用无锁链表方式暂时回收内存的机制。此外阐述了为了满足ART索引存储Key的要求
需要对实际存储的各种数据类型进行转换的方法。除此之外我们还会在本章中介绍如何将索引模块嵌入数据库事务模块中，因为通常情况下
索引模块和事务模块都是深度绑定的。我们是如何使得索引的创建删除操作（DDL）和对索引进行的增删改查操作（DML）可以并发执行的。

第四章主要是将第二章所有的详细设计进行具体实现，这个章节主要是展示各个子模块的类图。包括ART索引内部节点的类图定义，ART索引树的类图定义和相关接口的定义，
乐观级联锁的具体实现方式，基于Epoch的垃圾回收机制部分的详细设计，索引并发控制机制下，索引查询，插入，删除，范围查询等接口的伪代码描述，底层存储格式等相关的详细设计。
综上阐述了基于乐观级联锁的ART索引的详细实现，并且加入了我们实际实现中的优化点以及针对工程的思考。

第五章对实现的索引从功能和性能两方面进行测试评估，从功能性测试上来看，首先需要保证单线程下索引的正确性。然后需要保证多线程同时操作时，并发控制算法可以保证多线程
对索引的访问，保证索引查询结果的正确性。此外，垃圾回收机制也需要保证该索引模块在乐观并发控制的情况下不会产生内存泄漏。
同时设计针对性的用例评估其在多读少写场景下的性能。之后我们对测试的结果进行分析。

第六章对本文所做的工作进行总结，并对后续工作以及未来的方向提出个人的看法。
